-- 7. Inductive Types
  /- Every inductive type comes with introduction rules, which show how to 
     construct an element of the type, and elimination rules, which show how 
     to “use” an element of the type in another construction. We have already 
     seen the introduction rules for an inductive type: 
     they are just the constructors that are specified in the definition of the type. 
     The elimination rules provide for a principle of recursion on the type, which 
     includes, as a special case, a principle of induction as well. -/

#print "==========================================="
#print "Section 7.1. Enumerated Types"
#print " "

namespace Sec_7_1
  -- The simplest kind of inductive type is a type with a finite, enumerated list of elements.
  inductive weekday : Type
  | Sunday : weekday
  | Monday : weekday
  | Tuesday : weekday
  | Wednesday : weekday
  | Thursday : weekday
  | Friday : weekday
  | Saturday : weekday

  #check weekday.Monday
  open weekday
  #check Monday

  -- Sunday, Monday, ..., Saturday are distinct elements of weekday, with no special properties.

  /- The elimination principle `weekday.rec` is defined with `weekday` and its constructors. 
     `weekday.rec` is aka a recursor; it is what makes the type "inductive": it allows us 
     to define a function on weekday by assigning values corresponding to each constructor. 
     Intuition: an inductive type is exhaustively generated by its constructors, and has no 
     elements beyond those they construct. -/

  /- We will use a slight variant of `weekday.rec`, called `weekday.rec_on`, also generated 
     automatically and taking its arguments in a more convenient order.  -/

  -- Let's import `nat` and use `weekday.rec_on` to define a fn from weekday to natural numbers:

  def number_of_day (d : weekday) : ℕ := weekday.rec_on d 1 2 3 4 5 6 7

  #reduce number_of_day weekday.Sunday  -- result: 1
  #reduce number_of_day Sunday          -- (`weekday` is already opened, so this works too)
  #reduce number_of_day Thursday        -- result: 5

  /- The first (explicit) argument to `rec_on` is the element `d` being "analyzed." 
     The next seven arguments are the values corresponding to the seven constructors. 
     Note that `number_of_day weekday.Sunday` evaluates to 1: the computation rule for
     `rec_on` sees that `Sunday` is a constructor, and returns the appropriate argument. -/

  /- Below we see a more restricted variant of `rec_on` called `cases_on`. For enumerated types,
     `rec_on` and `cases_on` are the same, but the label `cases_on` emphasizes that the 
     definition is really a definition by cases. -/

  def number_of_day' (d : weekday) : ℕ := weekday.cases_on d 1 2 3 4 5 6 7

  

/-It is often useful to group definitions and theorems related to a structure in a namespace with the same name. For example, we can put the number_of_day function in the weekday namespace. We are then allowed to use the shorter name when we open the namespace. -/

/-The names rec_on and cases_on are generated automatically. As noted above, they are protected to avoid name clashes. In other words, they are not provided by default when the namespace is opened. However, you can explicitly0/

end Sec_7_1


#print "==========================================="
#print "Section 7.2. Constructors with Arguments"
#print " "

namespace Sec_7_2

end Sec_7_2


#print "==========================================="
#print "Section 7.3. Inductively Defined Propositions"
#print " "

namespace Sec_7_3

end Sec_7_3


#print "==========================================="
#print "Section 7.4. Defining the Natural Numbers"
#print " "

namespace Sec_7_4

end Sec_7_4


#print "==========================================="
#print "Section 7.5. Other Recursive Data Types"
#print " "

namespace Sec_7_5

end Sec_7_5


#print "==========================================="
#print "Section 7.6. Tactics for Inductive Types"
#print " "

namespace Sec_7_6

end Sec_7_6


#print "==========================================="
#print "Section 7.7. Inductive Families"
#print " "

namespace Sec_7_7

end Sec_7_7


#print "==========================================="
#print "Section 7.8. Axiomatic Details"
#print " "

namespace Sec_7_8

end Sec_7_8


#print "==========================================="
#print "Section 7.9. Mutual and Nested Inductive Types"
#print " "

namespace Sec_7_9

end Sec_7_9


#print "==========================================="
#print "Section 7.10. Exercises"
#print " "

namespace Sec_7_10

end Sec_7_10


