-- 7. Inductive Types
  /- Every inductive type comes with introduction rules, which show how to 
     construct an element of the type, and elimination rules, which show how 
     to “use” an element of the type in another construction. We have already 
     seen the introduction rules for an inductive type: 
     they are just the constructors that are specified in the definition of the type. 
     The elimination rules provide for a principle of recursion on the type, which 
     includes, as a special case, a principle of induction as well. -/

#print "==========================================="
#print "Section 7.1. Enumerated Types"
#print " "

namespace Sec_7_1
  -- The simplest kind of inductive type is a type with a finite, enumerated list of elements.
  inductive weekday : Type
  | Sunday : weekday
  | Monday : weekday
  | Tuesday : weekday
  | Wednesday : weekday
  | Thursday : weekday
  | Friday : weekday
  | Saturday : weekday

  #check weekday.Monday
  open weekday
  #check Monday

  -- Sunday, Monday, ..., Saturday are distinct elements of weekday, with no special properties.

  /- The elimination principle `weekday.rec` is defined with `weekday` and its constructors. 
     `weekday.rec` is aka a recursor; it is what makes the type "inductive" and allows us 
     to define a function on weekday by assigning values corresponding to each constructor. 
     Intuition: an inductive type is exhaustively generated by its constructors, and has no 
     elements beyond those they construct. -/

  /- We will use a slight variant of `weekday.rec`, called `weekday.rec_on`, also generated 
     automatically and taking its arguments in a more convenient order.  -/

  -- Let's import `nat` and use `weekday.rec_on` to define a fn from weekday to natural numbers:

  def number_of_day (d : weekday) : ℕ := weekday.rec_on d 1 2 3 4 5 6 7

  #reduce number_of_day weekday.Sunday  -- result: 1
  #reduce number_of_day Sunday          -- (`weekday` is already opened, so this works too)
  #reduce number_of_day Thursday        -- result: 5

  /- The first (explicit) argument to `rec_on` is the element `d` being "analyzed." 
     The next seven arguments are the values corresponding to the seven constructors. 
     Note that `number_of_day weekday.Sunday` evaluates to 1: the computation rule for
     `rec_on` sees that `Sunday` is a constructor, and returns the appropriate argument. -/

  /- A more restricted variant of `rec_on` is `cases_on`. For enumerated types, `rec_on` 
     and `cases_on` are the same, but `cases_on` emphasizes that the definition is by cases. -/

  def number_of_day' (d : weekday) : ℕ := weekday.cases_on d 1 2 3 4 5 6 7

  /- It is useful to group related definitions and theorems in a single namespace. 
     We can put `number_of_day` in the `weekday` namespace and then use the shorter name 
     when we open the namespace. -/

  /- The names rec_on and cases_on are generated automatically, but they are protected to 
     avoid name clashes, so they're not provided by default when the namespace is opened. 
     However, you can explicitly declare aliases for them using `renaming`. -/

  namespace weekday
    @[reducible]
    private def cases_on := @weekday.cases_on

    def number_of_day (d : weekday) : nat :=
      cases_on d 1 2 3 4 5 6 7
  end weekday

  -- We can define functions from weekday to weekday:
  namespace weekday
    def next (d : weekday) : weekday :=
      weekday.cases_on d Monday Tuesday Wednesday Thursday Friday Saturday Sunday

    def previous (d : weekday) : weekday :=
      weekday.cases_on d Saturday Sunday Monday Tuesday Wednesday Thursday Friday 

    #reduce next (next Tuesday)
    #reduce next (previous Tuesday)

    example (d : weekday) : next (previous d) = d := 
    weekday.cases_on d 
      (show next (previous Sunday) = Sunday, from rfl)
      (show next (previous Monday) = Monday, from rfl) -- etc...
      -- ...but the show is just for clarity; we can just use `rfl` by itself
      -- as we do for the remaining cases
      rfl rfl rfl rfl rfl

    -- with tactics, we can be even more concise
    example (d : weekday) : next (previous d) = d := 
      by apply weekday.cases_on d; refl
  end weekday

  -- Some fundamental data types in the Lean library are instances of enumerated types.
  namespace hide

    -- use `hide` so they don't conflict with the stdlib.

    inductive empty : Type  -- an inductive data type with no constructors

    inductive unit : Type | star : unit

    inductive bool : Type
    | ff : bool
    | tt : bool

    
    /- As an exercise, think about the introduction and elimination rules for these types,
       and define boolean operations `band`, `bor`, `bnot` on the boolean, and verifying 
       common identities; e.g., define `band` using a case split: -/

    def band (b1 b2 : bool) : bool := bool.cases_on b1 bool.ff b2
    def bor (b1 b2 : bool) : bool := bool.cases_on b1 b2 bool.tt 
    def bnot (b : bool) : bool := bool.cases_on b bool.tt bool.ff 


    #reduce band bool.tt bool.tt   -- returns bool.tt
    #reduce band bool.ff bool.tt   -- returns bool.ff
    #reduce bor bool.tt bool.ff    -- returns bool.tt
    #reduce bor bool.ff bool.ff    -- returns bool.ff
    #reduce bnot bool.ff           -- returns bool.tt
    #reduce bnot bool.tt           -- returns bool.ff

-- Similarly, most identities can be proved by introducing suitable case splits, and then using rfl.

  end hide

end Sec_7_1


#print "==========================================="
#print "Section 7.2. Constructors with Arguments"
#print " "

namespace Sec_7_2
  /- Enumerated types are a special case of inductive types, in which constructors take 
     no arguments. In general, a "construction" can depend on data, which is then represented 
     in the constructed argument. Consider the definitions of the product and sum types:-/

  universes u v

  namespace hide
    inductive prod (α : Type u) (β : Type v) | mk : α → β → prod
    inductive sum (α : Type u) (β : Type v) | inl {} : α → sum | inr {} : β → sum
  end hide
  
  /- To define a function on prod α β, we assume input of the form prod.mk a b, and specify
     the output in terms of a and b. For example, here is the definition of the two projections 
     for prod.  -/

  -- Remember the std lib uses α × β to denote prod α β and uses (a, b) for prod.mk a b.
  def fst {α : Type u} {β : Type v} (p : α × β) : α := prod.rec_on p (λ a b, a)
  def snd {α : Type u} {β : Type v} (p : α × β) : β := prod.rec_on p (λ a b, b)

  /- `fst` takes pair `p`, applies recursor `prod.rec_on p (λ a b, a)`---which interprets 
     `p` as pair `prod.mk a b`---then uses the 2nd arg to determine what to do with a and b. -/

  -- another example
  def prod_example (p : bool × ℕ) : ℕ := prod.rec_on p (λ b n, cond b (2 * n) (2 * n + 1))

  #reduce prod_example (tt, 3)  -- returns 6
  #reduce prod_example (ff, 3)  -- returns 7

  -- `cond` is a boolean conditional: `cond b t1 t2` returns `t1` if `b` is true, and `t2` 
  -- otherwise. (It has the same effect as `bool.rec_on b t2 t1`.)

  /- `sum` has two constructors, `inl` and `inr` and each takes one explicit argument. 
     To define a function on `sum α β`, we must handle 2 cases: if the input is of the form
     `inl a` (resp., `inr b`) then we must specify an output value in terms of a (resp `b`). -/

  def sum_example (s : ℕ ⊕ ℕ) : ℕ := sum.cases_on s (λ n, 2*n) (λ n, 2*n + 1)

  #reduce sum_example (sum.inl 3) -- returns 6
  #reduce sum_example (sum.inr 3) -- returns 7

  -- Lean's inductive def syntax allows named args for constructors before the colon:

  namespace hide₂
    inductive prod (α : Type) (β : Type) | mk (fst : α) (snd : β) : prod
    inductive sum (α : Type) (β : Type) | inl {} (a : α) : sum | inr {} (b : β) : sum
    /- These result in essentially the same types as the ones above. In `sum`, `{}` refers to 
       the parameters, `α` and `β`; braces specify which args are meant to be left implicit. -/
  end hide₂

  /- A type, like `prod`, that has only one constructor is purely conjunctive: 
     the constructor simply packs the list of arguments into a single piece of data, 
     essentially a tuple where the type of subsequent arguments can depend on the type 
     of the initial argument. We can think of such a type as a "record" or a "structure."  -/

  /- In Lean, the keyword `structure` can be used to define such an inductive type as well 
     as its projections, at the same time. -/

  namespace hide₃
    structure prod (α β : Type) := mk :: (fst : α) (snd : β)
    /- This simultaneously introduces the inductive type, `prod`, its constructor, `mk`, the
       usual eliminators (`rec` and `rec_on`), as well as the projections, `fst` and `snd`. -/
  end hide₃

    /- If you don't name the constructor, Lean uses `mk` as a default. For example, the 
       following defines a record to store a color as a triple of RGB values: -/

  structure color := (red : ℕ) (green : ℕ) (blue : ℕ)
  def yellow := color.mk 255 255 0
  #reduce color.red yellow     -- result: 255  (`color.red` is projection onto first component)
  #reduce color.green yellow   -- result: 255
  #reduce color.blue yellow    -- result: 0

  -- `structure` is especially useful for defining algebraic structures!!!!!!
  -- Lean provides substantial infrastructure to support working with them. 

  -- Here's the definition of a semigroup:

  structure Semigroup := (carrier : Type u) 
    (mul : carrier → carrier → carrier)
    (mul_assoc : ∀ a b c, mul (mul a b) c = mul a (mul b c))

  -- ==> More examples in CHAPTER 9!!!!!!! <==

  -- Recall, sigma types are also known as the "dependent product" type:

  namespace hide₄
    inductive sigma {α : Type u} (β : α → Type v) | dpair : Π a : α, β a → sigma

    -- Two more inductive types in the library are `option` and `inhabited`.
    inductive option (α : Type u) 
    | none {} : option 
    | some    : α → option

    inductive inhabited (α : Type u)
    | mk : α → inhabited
  end hide₄

  -- `option` type enables us to define partial functions

  /- In the semantics of dependent type theory, there is no built-in notion of a partial 
     function. Every element of a function type `α → β` or a Pi type `Π x : α, β` is assumed 
     total. The `option` type enables us to represent partial functions. An element of 
     `option β` is either `none` or of the form `some b`, for some value `b : β`. Thus,
     `α → option β` is the type of partial functions from `α` to `β`; if `a : α`, then 
     `f a` either returns `none`, indicating the `f` is "undefined" at `a`, or `some b`. -/

  /- An element of `inhabited α` is simply a witness to existence of an element of `α`. 
     `inhabited` is actually an example of a **type class** in Lean: Lean can be told that
     suitable base types are inhabited, and can automatically infer that other constructed 
     types are inhabited on that basis. -/

  /- As exercises, develop a notion of composition for partial functions from `α` to `β` and 
     `β` to `γ`, and show that it behaves as expected. -/

  /- Also, show that `bool` and `nat` are inhabited, that the product of two inhabited types
     is inhabited, and that the type of functions to an inhabited type is inhabited. -/
  
end Sec_7_2


#print "==========================================="
#print "Section 7.3. Inductively Defined Propositions"
#print " "

/- Inductively defined types can live in any type universe, including the bottom-most one, 
   `Prop`. In fact, this is exactly how the logical connectives are defined. -/

namespace Sec_7_3
  namespace hide₅
    inductive false : Prop
    inductive true : Prop | intro : true
    inductive and (a b : Prop) : Prop | intro : a → b → and
    inductive or (a b : Prop) : Prop 
    | intro_left : a → or 
    | intro_right : b → or

    -- Alternatively, we could give names to the inhabitants:
    inductive and_alt (P Q : Prop) : Prop | intro (a : P) (b : Q) : and_alt
    inductive or_alt (P Q : Prop) : Prop
    | intro_left (a : P) : or_alt
    | intro_right (b : Q) : or_alt
  end hide₅

  -- Think about how these give rise to the intro and elim rules we've already seen.

  -- There are rules that govern what the eliminator of an inductive type can eliminate to;
  -- that is, what kinds of types can be the target of a recursor.

  /- Roughly speaking, what characterizes inductive types in Prop is that one can only 
     eliminate to other types in Prop. This agrees with the fact that if `p : Prop`, then
     an element `hp : p` carries no info. (There is one exception discussed below.) -/

  -- Even the existential quantifier is inductively defined:

  namespace hide₆
    universe u

    inductive Exists {α : Type u} (p : α → Prop) : Prop
    | intro : ∀(a : α), p a → Exists

    inductive Exists_alt {α : Type u} (p : α → Prop) : Prop
    | intro (w : ∀(a : α), p a) : Exists_alt
  
    def exists.intro := @Exists.intro
  end hide₆

  -- The notation `∃ x : α, p` is syntactic sugar for `Exists (λ x : α, p)`.

  /- The defs of `false`, `true`, `and`, and `or` are analogous to the defs of 
     `empty`, `unit`, `prod`, and `sum`. The difference is the former yield
     elements of `Prop`, and the latter yield elements of `Type u` for some `u`. -/

  -- Similarly, `∃ x : α, p` is a `Prop`-valued variant of `Σ x : α, p`.

  /- Another inductive type, denoted `{x : α | p}`, is sort of a hybrid between 
     `∃ x : α, P` and `Σ x : α, P`. It is the `subtype` type. -/

  namespace hide₇
    universe u
    inductive subtype {α : Type u} (p : α → Prop)
    | mk : Π(x : α), p x → subtype

    inductive subtype_alt {α : Type u} (p : α → Prop)
    | mk (w : Π(x : α), p x) : subtype_alt
  end hide₇

 -- This next example is unclear to me.
 namespace confusing_example
   universe u
   variables {α : Type u} (p : α → Prop)
   #check subtype p        -- why is the result `subtype p : Type u` ??
   #check {x : α // p x }  -- why is the result `{x // p x } : Type u` ??
 end confusing_example

end Sec_7_3

#print "==========================================="
#print "Section 7.4. Defining the Natural Numbers"
#print " "

namespace Sec_7_4

end Sec_7_4


#print "==========================================="
#print "Section 7.5. Other Recursive Data Types"
#print " "

namespace Sec_7_5

end Sec_7_5


#print "==========================================="
#print "Section 7.6. Tactics for Inductive Types"
#print " "

namespace Sec_7_6

end Sec_7_6


#print "==========================================="
#print "Section 7.7. Inductive Families"
#print " "

namespace Sec_7_7

end Sec_7_7


#print "==========================================="
#print "Section 7.8. Axiomatic Details"
#print " "

namespace Sec_7_8

end Sec_7_8


#print "==========================================="
#print "Section 7.9. Mutual and Nested Inductive Types"
#print " "

namespace Sec_7_9

end Sec_7_9


#print "==========================================="
#print "Section 7.10. Exercises"
#print " "

namespace Sec_7_10

end Sec_7_10


